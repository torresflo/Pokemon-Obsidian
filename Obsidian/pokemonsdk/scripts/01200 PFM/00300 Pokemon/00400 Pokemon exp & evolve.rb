module PFM
  class Pokemon
    # Tell if PSDK test evolve on form 0 or the current form
    EVOLVE_ON_FORM0 = true
    # Return the base experience of the Pokemon
    # @return [Integer]
    def base_exp
      return GameData::Pokemon.get_data(@sub_id || @id, @form).base_exp
    end
    # Return the exp curve type ID
    # @return [Integer]
    def exp_type
      return GameData::Pokemon.get_data(@sub_id || @id, @form).exp_type
    end
    # Return the exp curve
    # @return [Array<Integer>]
    def exp_list
      return GameData::EXP_TABLE[exp_type]
    end
    # Return the required exp to increase the Pokemon's level
    # @return [Integer]
    def exp_lvl
      data = GameData::EXP_TABLE[exp_type]
      v = data[@level + 1]
      return data[@level] if !v || ($pokemon_party&.level_max_limit).to_i <= @level
      return v
    end
    # Return the text of the amount of exp the pokemon needs to go to the next level
    # @return [String]
    def exp_remaining_text
      expa = self.exp_lvl - self.exp
      expa = 0 if expa < 0
      return expa.to_s
    end
    # Return the text of the current pokemon experience
    # @return [String]
    def exp_text
      "#@exp"
    end
    # Change the Pokemon total exp
    # @param v [Integer] the new exp value
    def exp=(v)
      @exp = v.to_i
      _exp_lvl = self.exp_lvl
      if(_exp_lvl >= @exp)
        _exp_last = GameData::EXP_TABLE[exp_type][@level]
        delta = _exp_lvl - _exp_last
        current = exp - _exp_last
        @exp_rate = (delta == 0 ? 1 : current / delta.to_f) #> Vérifier pour la correction
      else
        @exp_rate = (@level < $pokemon_party.level_max_limit ? 1 : 0)
      end
    end
    # Increase the level of the Pokemon
    # @return [Boolean] if the level has successfully been increased
    def level_up
      return false if @level >= $pokemon_party.level_max_limit
      _exp_last = GameData::EXP_TABLE[exp_type][@level]
      delta = self.exp_lvl - _exp_last
      self.exp += (delta - (exp - _exp_last))
      return true
    end

    # Generate the level up stat list for the level up window
    # @return [Array<Array<Integer>>] list0, list1 : old, new basis value
    def level_up_stat_refresh
      st = $game_temp.in_battle
      $game_temp.in_battle = false
      list0 = [max_hp, atk_basis, dfe_basis, ats_basis, dfs_basis, spd_basis]
      @level += 1 if @level < $pokemon_party.level_max_limit
      self.exp = exp_list[@level] if @exp < exp_list[@level].to_i
      self.exp = exp # Fix the exp amount
      hp_diff = list0[0] - @hp
      list1 = [max_hp, atk_basis, dfe_basis, ats_basis, dfs_basis, spd_basis]
      self.hp = (max_hp - hp_diff) if @hp > 0
      $game_temp.in_battle = st
      return [list0, list1]
    end

    # Show the level up window
    # @param list0 [Array<Integer>] old basis stat list
    # @param list1 [Array<Integer>] new basis stat list
    # @param z_level [Integer] z superiority of the Window
    def level_up_window_call(list0, list1, z_level)
      window = UI::LevelUpWindow.new(nil, self, list0, list1)
      window.z = z_level
      Graphics.sort_z
      until Input.trigger?(:A)
        window.update
        Graphics.update
      end
      $game_system.se_play($data_system.decision_se)
      window.dispose
    end

    # Change the level of the Pokemon
    # @param lvl [Integer] the new level of the Pokemon
    def level=(lvl)
      return if lvl == @level
      lvl = lvl.clamp(1, $pokemon_party.level_max_limit)
      @exp = exp_list[lvl]
      @exp_rate = 0
      @level = lvl
    end

    # Check if the Pokemon can evolve and return the evolve id if possible
    # @param reason [Symbol] evolve check reason (:level_up, :trade, :stone)
    # @param extend_data [Hash, nil] extend_data generated by an item
    # @return [Integer, false] if the Pokemon can evolve, the evolve id, otherwise false
    def evolve_check(reason = :level_up, extend_data = nil)
      return false if GameData::Item.db_symbol(@item_holding) == :everstone
      data = EVOLVE_ON_FORM0 ? GameData::Pokemon.get_data(@id, 0) : get_data
      if(reason == :level_up and data.evolution_level and data.evolution_level <= @level and data.evolution_id and data.evolution_id != 0)
        return data.evolution_id
      end
      return false unless data.special_evolution
      stone = (reason == :stone)
      data.special_evolution.each do |e|
        #>Prévention des pierres
        next if stone and !e[:stone]
        #>Echanger contre
        next if(e[:trade_with] and e[:trade_with] != extend_data)
        #>Niveau minimum
        next if(e[:min_level] and e[:min_level] > @level)
        #>Niveau maximum
        next if(e[:max_level] and e[:max_level] < @level)
        #>En portant un objet
        next if(e[:item_hold] and e[:item_hold] != @item_holding)
        #>Bonheur min
        next if(e[:min_loyalty] and e[:min_loyalty] > @loyalty)
        #>Bonheur max
        next if(e[:max_loyalty] and e[:max_loyalty] < @loyalty)
        #>Les attaques
        if(e[:skill_1])
          next unless skill_learnt?(e[:skill_1])
          if(e[:skill_2])
            next unless skill_learnt?(e[:skill_2])
            if(e[:skill_3])
              next unless skill_learnt?(e[:skill_3])
              if(e[:skill_4])
                next unless skill_learnt?(e[:skill_4])
              end
            end
          end
        end
        #>Météo spécifique
        next if(e[:weather] and $env.weather != e[:weather])
        #>Être sur un tag
        next if(e[:env] and $game_player.system_tag != e[:env])
        #>Un genre spécifique
        next if(e[:gender] and @gender != e[:gender])
        #>Application d'une pierrre
        next if(e[:stone] and e[:stone] != extend_data)
        #>Moment de la journée
        next if(e[:day_night] and e[:day_night] != $game_variables[::Yuki::Var::TJN_Tone])
        #>Appel de fonction
        next if(e[:func] and !self.send(*e[:func]))
        #>Sur des maps
        next if(e[:maps] and !e[:maps].include?($game_map.map_id))
        if(reason == :trade)
          return e[:trade] if e[:trade]
        else
          return e[:id] if e[:id]
        end
      end
      return false
    end
    # Change the id of the Pokemon
    # @param new_id [Integer] the new id of the Pokemon
    def id=(new_id)
      @character = nil
      if new_id && GameData::Pokemon.id_valid?(new_id) && (forms = GameData::Pokemon.get_forms(new_id))
        @id = new_id
        @form = 0 unless forms[@form]
        @form = form_generation(-1) if @form == 0
        @form = 0 unless forms[@form]
        update_ability
      end
    end
    # Update the Pokemon Ability
    def update_ability
      if @ability_index
        @ability_current = @ability = get_data.abilities[@ability_index.to_i]
      else
        @ability_current = @ability
      end
    end
    # Check evolve condition to evolve in Hitmonlee (kicklee)
    # @return [Boolean] if the condition is valid
    def elv_kicklee
      self.atk > self.dfe
    end
    # Check evolve condition to evolve in Hitmonchan (tygnon)
    # @return [Boolean] if the condition is valid
    def elv_tygnon
      self.atk < self.dfe
    end
    # Check evolve condition to evolve in Hitmontop (Kapoera)
    # @return [Boolean] if the condition is valid
    def elv_kapoera
      self.atk == self.dfe
    end
    # Check evolve condition to evolve in Silcoon (Armulys)
    # @return [Boolean] if the condition is valid
    def elv_armulys
      ((@code & 0xFFFF) % 10) <= 4
    end
    # Check evolve condition to evolve in Cascoon (Blindalys)
    # @return [Boolean] if the condition is valid
    def elv_blindalys
      !self.elv_armulys
    end
    # Check evolve condition to evolve in Mantine (Démanta)
    # @return [Boolean] if the condition is valid
    def elv_demanta
      $pokemon_party.has_pokemon?(223)
    end
    # Check evolve condition to evolve in Pangoro (Pandarbare)
    # @return [Boolean] if the condition is valid
    def elv_pandarbare
      $actors.each do |i|
        return true if i and i.type_dark?
      end
      return false
    end
    # Check evolve condition to evolve in Malamar (Sepiatroce)
    # @note uses :DOWN to validate the evolve condition
    # @return [Boolean] if the condition is valid
    def elv_sepiatroce
      return Input.press?(:DOWN)
    end
    # Check evolve condition to evolve in Sylveon (Nymphali)
    # @return [Boolean] if the condition is valid
    def elv_nymphali
      @skills_set.each do |skill|
        return true if skill and skill.type_fairy?
      end
      return false
    end
  end
end
